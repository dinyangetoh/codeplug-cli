import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { mkdtemp, readFile, writeFile, mkdir, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import type { Convention } from '../../../src/config/types.js';
import { ClaudeFormatter } from '../../../src/core/exporter/formatters/ClaudeFormatter.js';
import { CursorFormatter } from '../../../src/core/exporter/formatters/CursorFormatter.js';
import { CopilotFormatter } from '../../../src/core/exporter/formatters/CopilotFormatter.js';
import { JsonFormatter } from '../../../src/core/exporter/formatters/JsonFormatter.js';
import { CiFormatter } from '../../../src/core/exporter/formatters/CiFormatter.js';
import { ExportEngine } from '../../../src/core/exporter/ExportEngine.js';
import { FreshnessChecker } from '../../../src/core/exporter/FreshnessChecker.js';

function makeConvention(overrides: Partial<Convention> = {}): Convention {
  return {
    id: 'conv-1',
    dimension: 'naming',
    rule: 'Use PascalCase for component filenames',
    confidence: 0.92,
    confirmed: true,
    examples: ['UserProfile.tsx', 'DashboardView.tsx'],
    severity: 'high',
    ...overrides,
  };
}

const SAMPLE_CONVENTIONS: Convention[] = [
  makeConvention(),
  makeConvention({
    id: 'conv-2',
    dimension: 'testing',
    rule: 'Co-locate test files next to source',
    severity: 'medium',
    examples: ['src/__tests__/utils.test.ts'],
  }),
  makeConvention({
    id: 'conv-3',
    dimension: 'imports',
    rule: 'Use absolute imports via path aliases',
    severity: 'low',
    examples: ['@/components/Button'],
  }),
  makeConvention({
    id: 'conv-4',
    dimension: 'error-handling',
    rule: 'Always wrap async calls in try/catch',
    severity: 'critical',
    examples: ['src/api/fetchUser.ts'],
  }),
];

describe('ClaudeFormatter', () => {
  const formatter = new ClaudeFormatter();

  it('should produce a CLAUDE.md filename', () => {
    expect(formatter.filename).toBe('CLAUDE.md');
    expect(formatter.targetDir).toBe('.');
  });

  it('should include project conventions header', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('# Project Conventions');
  });

  it('should group by dimension with section headers', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('## Naming Conventions');
    expect(output).toContain('## Testing Standards');
    expect(output).toContain('## Import Conventions');
    expect(output).toContain('## Error Handling');
  });

  it('should include severity indicators', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('**[HIGH]**');
    expect(output).toContain('**[MEDIUM]**');
    expect(output).toContain('**[LOW]**');
    expect(output).toContain('**[CRITICAL]**');
  });

  it('should include examples', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('`UserProfile.tsx`');
    expect(output).toContain('`DashboardView.tsx`');
  });

  it('should include generation footer', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('Generated by CodePlug');
  });

  it('should handle empty conventions', () => {
    const output = formatter.format([]);
    expect(output).toContain('# Project Conventions');
    expect(output).not.toContain('##');
  });
});

describe('CursorFormatter', () => {
  const formatter = new CursorFormatter();

  it('should produce conventions.mdc in .cursor/rules', () => {
    expect(formatter.filename).toBe('conventions.mdc');
    expect(formatter.targetDir).toBe('.cursor/rules');
  });

  it('should include YAML frontmatter', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toMatch(/^---\n/);
    expect(output).toContain('alwaysApply: true');
    expect(output).toContain('description:');
  });

  it('should include conventions grouped by dimension', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('## Naming Conventions');
    expect(output).toContain('Use PascalCase for component filenames');
  });

  it('should include severity tags', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('**[HIGH]**');
  });
});

describe('CopilotFormatter', () => {
  const formatter = new CopilotFormatter();

  it('should produce copilot-instructions.md in .github', () => {
    expect(formatter.filename).toBe('copilot-instructions.md');
    expect(formatter.targetDir).toBe('.github');
  });

  it('should include Copilot instructions header', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('# GitHub Copilot Instructions');
  });

  it('should use severity-based prefixes', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('**SHOULD**:');
    expect(output).toContain('**PREFER**:');
    expect(output).toContain('**CONSIDER**:');
    expect(output).toContain('**MUST**:');
  });

  it('should include rule text', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    expect(output).toContain('Use PascalCase for component filenames');
  });
});

describe('JsonFormatter', () => {
  const formatter = new JsonFormatter();

  it('should produce codeplug-export.json in .codeplug/exports', () => {
    expect(formatter.filename).toBe('codeplug-export.json');
    expect(formatter.targetDir).toBe('.codeplug/exports');
  });

  it('should produce valid JSON', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    expect(parsed).toBeDefined();
  });

  it('should include schema and metadata', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    expect(parsed.$schema).toBe('codeplug-export-v1');
    expect(parsed.conventionCount).toBe(SAMPLE_CONVENTIONS.length);
    expect(parsed.exportedAt).toBeDefined();
  });

  it('should include all conventions with correct fields', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    expect(parsed.conventions).toHaveLength(SAMPLE_CONVENTIONS.length);

    const first = parsed.conventions[0];
    expect(first.id).toBe('conv-1');
    expect(first.dimension).toBe('naming');
    expect(first.rule).toBe('Use PascalCase for component filenames');
    expect(first.severity).toBe('high');
    expect(first.confidence).toBe(0.92);
    expect(first.confirmed).toBe(true);
    expect(first.examples).toEqual(['UserProfile.tsx', 'DashboardView.tsx']);
  });

  it('should handle empty conventions', () => {
    const output = formatter.format([]);
    const parsed = JSON.parse(output);
    expect(parsed.conventionCount).toBe(0);
    expect(parsed.conventions).toEqual([]);
  });
});

describe('CiFormatter', () => {
  const formatter = new CiFormatter();

  it('should produce ci-report.json in .codeplug', () => {
    expect(formatter.filename).toBe('ci-report.json');
    expect(formatter.targetDir).toBe('.codeplug');
  });

  it('should produce valid SARIF-like JSON', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    expect(parsed.version).toBe('2.1.0');
    expect(parsed.$schema).toContain('sarif');
  });

  it('should map conventions to rules', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    const rules = parsed.runs[0].tool.driver.rules;
    expect(rules).toHaveLength(SAMPLE_CONVENTIONS.length);
    expect(rules[0].id).toBe('conv-1');
    expect(rules[0].shortDescription.text).toBe('Use PascalCase for component filenames');
  });

  it('should map severity to SARIF levels', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    const rules = parsed.runs[0].tool.driver.rules;

    const criticalRule = rules.find((r: { id: string }) => r.id === 'conv-4');
    expect(criticalRule.defaultConfiguration.level).toBe('error');

    const highRule = rules.find((r: { id: string }) => r.id === 'conv-1');
    expect(highRule.defaultConfiguration.level).toBe('warning');

    const mediumRule = rules.find((r: { id: string }) => r.id === 'conv-2');
    expect(mediumRule.defaultConfiguration.level).toBe('note');
  });

  it('should include results with locations from examples', () => {
    const output = formatter.format(SAMPLE_CONVENTIONS);
    const parsed = JSON.parse(output);
    const results = parsed.runs[0].results;
    expect(results).toHaveLength(SAMPLE_CONVENTIONS.length);
    expect(results[0].locations[0].physicalLocation.artifactLocation.uri).toBe('UserProfile.tsx');
  });
});

describe('ExportEngine', () => {
  const WORKSPACE_TMP = join(process.cwd(), '.test-tmp');
  let tmpDir: string;

  beforeEach(async () => {
    await mkdir(WORKSPACE_TMP, { recursive: true });
    tmpDir = await mkdtemp(join(WORKSPACE_TMP, '/codeplug-export-test-'));
  });

  afterEach(async () => {
    await rm(WORKSPACE_TMP, { recursive: true, force: true });
  });

  it('should export to a single target', async () => {
    const engine = new ExportEngine(tmpDir);
    const result = await engine.export(SAMPLE_CONVENTIONS, ['json']);

    expect(result.filesWritten).toBe(1);
    expect(result.files).toContain('.codeplug/exports/codeplug-export.json');

    const content = await readFile(join(tmpDir, '.codeplug/exports/codeplug-export.json'), 'utf-8');
    const parsed = JSON.parse(content);
    expect(parsed.conventionCount).toBe(SAMPLE_CONVENTIONS.length);
  });

  it('should export to multiple targets', async () => {
    const engine = new ExportEngine(tmpDir);
    const result = await engine.export(SAMPLE_CONVENTIONS, ['claude', 'cursor', 'copilot', 'json', 'ci']);

    expect(result.filesWritten).toBe(5);
    expect(result.files).toContain('CLAUDE.md');
    expect(result.files).toContain('.cursor/rules/conventions.mdc');
    expect(result.files).toContain('.github/copilot-instructions.md');
    expect(result.files).toContain('.codeplug/exports/codeplug-export.json');
    expect(result.files).toContain('.codeplug/ci-report.json');
  });

  it('should create target directories automatically', async () => {
    const engine = new ExportEngine(tmpDir);
    await engine.export(SAMPLE_CONVENTIONS, ['cursor']);

    const content = await readFile(join(tmpDir, '.cursor/rules/conventions.mdc'), 'utf-8');
    expect(content).toContain('# Project Conventions');
  });

  it('should throw for unknown target', async () => {
    const engine = new ExportEngine(tmpDir);
    await expect(engine.export(SAMPLE_CONVENTIONS, ['unknown'])).rejects.toThrow('Unknown export target');
  });

  it('should write valid content for claude target', async () => {
    const engine = new ExportEngine(tmpDir);
    await engine.export(SAMPLE_CONVENTIONS, ['claude']);

    const content = await readFile(join(tmpDir, 'CLAUDE.md'), 'utf-8');
    expect(content).toContain('# Project Conventions');
    expect(content).toContain('Naming Conventions');
  });
});

describe('FreshnessChecker', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await mkdtemp(join(tmpdir(), 'codeplug-fresh-test-'));
  });

  afterEach(async () => {
    await rm(tmpDir, { recursive: true, force: true });
  });

  it('should return true when no conventions file exists', async () => {
    const checker = new FreshnessChecker(tmpDir);
    expect(await checker.check()).toBe(true);
  });

  it('should return false when conventions exist but no exports', async () => {
    const codeplugDir = join(tmpDir, '.codeplug');
    await mkdir(codeplugDir, { recursive: true });
    await writeFile(join(codeplugDir, 'conventions.json'), '{}', 'utf-8');

    const checker = new FreshnessChecker(tmpDir);
    expect(await checker.check()).toBe(false);
  });

  it('should return true when exports are newer than conventions', async () => {
    const codeplugDir = join(tmpDir, '.codeplug');
    await mkdir(codeplugDir, { recursive: true });
    await writeFile(join(codeplugDir, 'conventions.json'), '{}', 'utf-8');

    await new Promise(r => setTimeout(r, 50));

    await writeFile(join(tmpDir, 'CLAUDE.md'), '# Conventions', 'utf-8');

    const checker = new FreshnessChecker(tmpDir);
    expect(await checker.check()).toBe(true);
  });

  it('should return false when conventions are newer than exports', async () => {
    await writeFile(join(tmpDir, 'CLAUDE.md'), '# Conventions', 'utf-8');

    await new Promise(r => setTimeout(r, 50));

    const codeplugDir = join(tmpDir, '.codeplug');
    await mkdir(codeplugDir, { recursive: true });
    await writeFile(join(codeplugDir, 'conventions.json'), '{}', 'utf-8');

    const checker = new FreshnessChecker(tmpDir);
    expect(await checker.check()).toBe(false);
  });
});
